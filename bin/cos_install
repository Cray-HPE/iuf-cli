#!/usr/bin/env python3

# Copyright 2022 Hewlett Packard Enterprise Development LP


# Note: We should be installing cos-2.3.38 or newer!  The older ones have a
# CFS problem.
"""The COS Installer"""

import argparse
from collections import OrderedDict
import json
import os
import sys
import yaml
import logging

from utils.vars import *
from utils.InstallLogger import *

from utils.InstallerUtils import CmdMgr

import utils.ShastaUpdate as main_ctrl


# pylint: disable=consider-using-f-string

install_logger = get_install_logger()

STAGES = OrderedDict({
    "hello": main_ctrl.hello,
    "process_product_media": main_ctrl.get_prods,
    "validate_products": main_ctrl.validate_products,
    "install_products": main_ctrl.install,
    "verify_product_import": main_ctrl.check_pods,
    "update_working_branches": main_ctrl.update_working_branches,
    "update_ncnp_config": main_ctrl.update_ncnp_config,
    "ncn_personalization": main_ctrl.ncn_personalization,
    "unload_dvs_and_lnet": main_ctrl.unload_dvs_and_lnet,
    "check_services": main_ctrl.check_services,
    "build_cos_compute_image": main_ctrl.build_cos_compute_image,
    "customize_cos_compute_image": main_ctrl.customize_cos_compute_image,
    "boot_computes": main_ctrl.boot_cos,
    "run_slurm_hello_world": main_ctrl.run_hello_world,
})

NOABORT_STAGES = [
    "boot_cos",
    "run_hello_world"
]

def format_tabbed_list(alist):
    """Format a list into text that's easier to read.  This is useful when
    a list needs to be displayed to a user."""
    retstr = ""
    for elt in alist:
        # hide the hello stage
        if elt != 'hello':
            retstr += "  {}\n".format(elt)

    return retstr


def is_option(option, cmdline_args):
    """Check if an option passed in via the input deck is a valid option."""

    return option in cmdline_args.keys()


def get_input_deck(cmdline_args):
    """Process the input deck.  The keys need to be converted to the
    argparse naming convention (i.e, replace '-' with '_')."""

    args_dict = {}

    format_type = cmdline_args.get("format", "json")
    if format_type is None:
        format_type = "json"

    if format_type not in ["json", "yaml"]:
        install_logger.error("The '-f/--format' argument needs to be either json or yaml")
        sys.exit(1)

    in_arg = cmdline_args.get("input_file")
    if in_arg and not os.path.exists(in_arg):
        install_logger.error("Input file {} does not exist".format(in_arg))
        sys.exit(1)
    elif in_arg:
        with open(in_arg, 'r', encoding='UTF-8') as fhandle:
            try:
                if format_type == 'yaml':
                    args_dict = yaml.load(fhandle, yaml.SafeLoader)
                else:
                    args_dict = json.load(fhandle)
            except (json.decoder.JSONDecodeError, yaml.scanner.ScannerError) as synerr:
                raise SyntaxError("Encountered an error loading {}: {}".format(in_arg, synerr)) from None

    return_dict = {}
    for arg in args_dict:
        new_key = arg.replace('-', '_')
        if not is_option(new_key, cmdline_args):
            install_logger.warning("WARNING: {} is not a valid key.  It will be ignored!".format(arg))
        else:
            return_dict[new_key] = args_dict[arg]

    return return_dict


def process_install(cmdline_args):
    """Process the arguments to the install subparser.  This function
    merges the commandline arguments with the arguments passed via the input
    file ('--input-file').  The arguments passed in via the commandline override
    those of the input file.  For example, if the input file has a
    begin-stage that differs from the one passed in via the commandline,
    the commandline option will be used."""

    # Override the input deck (if specified) with the arguments specified on the commandline.
    args_dict = {}
    used_args = {}
    for arg in cmdline_args:
        if cmdline_args[arg] is not None:
            used_args[arg] = cmdline_args[arg]

    if cmdline_args["input_file"]:
        args_dict = get_input_deck(cmdline_args)

    args_dict.update(used_args)

    # Do some error-handling with the stage-related args
    stages_list = list(STAGES.keys())
    begin_stage = stages_list[0]
    end_stage = stages_list[-1]
    skip_stages = args_dict['skip_stages'] if 'skip_stages' in args_dict else []

    stages_formatted = format_tabbed_list(stages_list)
    if "begin_stage" in args_dict and args_dict['begin_stage'] not in stages_list:
        install_logger.error("begin_stage ({}) must be one of the following:\n{}".format(args_dict['begin_stage'], stages_formatted))
        sys.exit(1)
    elif 'end_stage' in args_dict and args_dict['end_stage'] not in stages_list:
        install_logger.error("end_stage ({}) must be one of the following:\n{}".format(args_dict['end_stage'], stages_formatted))
        sys.exit(1)

    if 'run_stages' in args_dict:
        for stage in args_dict['run_stages']:
            if stage not in stages_list:
                install_logger.error("invalid stage ({}) found in '--run-stages' argument".format(stage))
                sys.exit(1)

    begin_stage = args_dict.get('begin_stage', begin_stage)
    end_stage = args_dict.get('end_stage', end_stage)

    # Let args_dict['run_stages'] override begin_stage and end_stage; that is,
    # if all three were passed in, run_stages wins.  Loop against stages_list
    # to preserve the execution order.
    if 'run_stages' in args_dict:
        install_logger.debug("got run_stages ...")
        got_first_stage = False
        for stage in stages_list:
            if stage in args_dict['run_stages'] and not got_first_stage:
                begin_stage = stage
                end_stage = stage
                got_first_stage = True
            elif stage in args_dict['run_stages']:
                end_stage = stage

    install_logger.info("STAGE SUMMARY: begin_stage={}, end_stage={}".format(begin_stage, end_stage))
    bad_skip = False
    for sstage in skip_stages:
        if sstage not in stages_list:
            install_logger.warning("WARNING: Stage {} is not a valid stage".format(sstage))
            bad_skip = True
    if bad_skip:
        sys.exit(1)

    begin_idx = stages_list.index(begin_stage)
    end_idx = stages_list.index(end_stage)
    install_logger.debug("begin_idx={}, end_idx={}, len(stages_list)={}".format(begin_idx, end_idx, len(stages_list)))
    stages = [stages_list[i] for i in range(begin_idx, end_idx + 1) if stages_list[i] not in skip_stages]
    install_logger.debug("stages={}".format(stages))
    install_logger.debug("(begin,end)_idx = ({},{})".format(begin_idx, end_idx))
    args_dict["stages"] = stages

    if 'media_dir' in args_dict:
        if not os.path.exists(args_dict['media_dir']):
            install_logger.error("media-dir {} does not exist.".format(args_dict['media_dir']))
            sys.exit(1)

    install_logger.debug("ARGS_DICT={}".format(args_dict))

    for stage in stages_list:
        if stage in stages:
            install_logger.info("Beginning stage: {}".format(stage))
            # a logging message using exc_info must be the very first thing called after the except
            # block starts, so I can't make all these decisions there
            if stage in NOABORT_STAGES:
                log_level=LOG_LEVELS["WARNING"]
            else:
                log_level=LOG_LEVELS["ERROR"]

            try:
                STAGES[stage](args_dict)
            except Exception as err:
                print("")
                install_logger.debug("Exception while executing {}".format(stage), exc_info=True)
                install_logger.critical("A '{}' error occured while executing {}".format(err, stage))
                install_logger.critical("Cannot continue, exiting.")
                print("")
                sys.exit(1)

def process_branch_update(args):
    """Process the arguments to the branch subparser"""
    install_logger.debug("process_branch_update, args={} ", args)

def process_list(args): #pylint: disable=unused-argument
    """Process the arguments to the list subparser"""
    stages = format_tabbed_list(STAGES)
    print(stages)

def process_debug_level(cmdline_args):
    install_logger_file_init(verbose=cmdline_args.get("verbose", False))
    if "level" in cmdline_args.keys() and cmdline_args["level"] != None:
        if cmdline_args["level"] in LOG_LEVELS.keys():
            level = LOG_LEVELS[cmdline_args["level"]]
            install_logger_stream_init(level, cmdline_args.get("verbose", False))
        else:
            logger.error("Unrecognized log level: {}".format(cmdline_args["level"]))
            sys.exit(1)
    else:
        install_logger_stream_init(verbose=cmdline_args.get("verbose", False))

    return

def process_dryrun(cmdline_args):
    """
    Sets the static CmdInterface interface to "dryrun" mode
    """
    dryrun = cmdline_args.get("dryrun", False)
    connection = CmdMgr.get_cmd_interface()
    connection.dryrun = dryrun

    if dryrun:
        addLoggingLevel('DRYRUN', logging.INFO + 1)
        install_logger.dryrun("Dryrun enabled")

def main():
    """Main entry point."""

    parser = argparse.ArgumentParser(description=
        """
       The COS installer.
        """
    )

    parser.add_argument("-i", "--input-file", action="store", help="""Input
        file used to control the install.   Command line arguments will
        override what is in the file.

        By default, the input file is assumed to be json.  Use this option in
        conjunction with '--format yaml' to use a yaml input""")

    parser.add_argument("-f", "--format", action="store",
        help="format on input ('-i' or '--input-file').  Accepts json or yaml")

    parser.add_argument("-s", "--state-dir", action="store",
        help="A directory used to store the current state of stages.  Defaults to $PWD/state")

    parser.add_argument("-m", "--media-dir", action="store",
        help="Location of installation media.  Defaults to $PWD/media")

    parser.add_argument("-d", "--dryrun", action="store_true",
        help="Run without making any changes to the system to see what would happen")

    parser.add_argument("-l", "--level", action="store",
        help="Set the debug level to the console", choices=LOG_LEVELS.keys())

    parser.add_argument("-v", "--verbose", action="store_true",
        help="Generates more verbose messages")

    # TODO: The stage-dir usage could use more verbiage. We might want to add
    # this to the install docs.  Describing it in detail in the help section
    # might be inappropriate.  Essentially, we need it because not all the stages
    # are fully independent; for example, we have an unpack stage, and an
    # install stage.  The install stage needs to install what was unpacked.

    subparsers = parser.add_subparsers(title="subcommands")

    install_sp = subparsers.add_parser("install")

    install_sp.add_argument("-b", "--begin-stage", action="store",
        help="The first stage to execute")

    install_sp.add_argument("-e", "--end-stage", action="store",
        help="The last stage to execute")

    install_sp.add_argument("-r", "--run-stages", nargs="+", action="store",
        help="Run only the specified stages")

    install_sp.add_argument("-s", "--skip-stages", nargs="+", action="store",
        help="Skip the execution of the specified stages.")

    install_sp.add_argument("-t", "--source-bos-sessiontemplate", action="store",
        help="BOS template to start from when booting COS")

    install_sp.add_argument("-crn", "--cos-recipe-name", action="store",
        help="The name of the recipe to build the COS compute image")

    install_sp.add_argument("-ncnp", "--ncn-personalization", action="store",
        default="ncn-personalization",
        help="The name of the ncn personalization config to update.  Defaults to 'ncn-personalization'")

    install_sp.set_defaults(func=process_install)

    bu_sp = subparsers.add_parser("branch-update", aliases=["bu"])
    bu_sp.add_argument("branches", nargs="+", action="store", default=["integration"],
        help="Branches to update.")
    bu_sp.set_defaults(func=process_branch_update)

    list_sp = subparsers.add_parser("list-stages", aliases=["ls"])
    list_sp.set_defaults(func=process_list)

    args = parser.parse_args()

    # Convert the args to a dict, and use that rather than the argparse
    # object.  This is so that we have a dictionary of all options, so that
    # we can more easily determine which values can be passed via an input
    # deck.
    args_dict = vars(args)

    if args_dict["media_dir"] is None:
        media_default = os.path.join(os.getcwd(), "media")
        args_dict["media_dir"] = media_default
        if not os.path.exists(media_default):
            os.mkdir(media_default)

    if args_dict["state_dir"] is None:
        state_default = os.path.join(os.getcwd(), "state")
        args_dict["state_dir"] = state_default
        if not os.path.exists(state_default):
            os.mkdir(state_default)

    process_debug_level(args_dict)
    process_dryrun(args_dict)
    install_logger.debug(args_dict)
    if len(sys.argv) < 2:
        install_logger.error("{} requires at least 1 argument".format(sys.argv[0]))
        parser.print_help(sys.stderr)
        sys.exit(1)

    # some sanity testing
    if not os.path.exists(args_dict["media_dir"]):
        install_logger.error("Media directory {} does not exist.".format(args_dict["media_dir"]))
        sys.exit(1)

    if not os.path.exists(args_dict["state_dir"]):
        install_logger.error("State directory {} does not exist.".format(args_dict["state_dir"]))
        sys.exit(1)

    try:
        args.func(args_dict)
    except AttributeError:
        install_logger.error("A subcommand was not specified.")
        sys.exit(1)
if __name__ == "__main__":
    main()
