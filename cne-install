#!/usr/bin/env python3

# Copyright 2022 Hewlett Packard Enterprise Development LP

"""The Compute Node Environment (CNE) Installer"""

import argparse
from collections import OrderedDict
import json
import os
import sys
import yaml
import logging
import textwrap
import datetime
import tarfile

from utils.vars import *
from utils.InstallLogger import *

from utils.InstallerUtils import CmdMgr
from utils.InstallerUtils import elapsed_time
from utils.InstallerUtils import formatted
from utils.InstallerUtils import get_product_prefixes
from utils.InstallerUtils import print_table
from utils.Config import Config
from utils.Config import InvertableArgument

import utils.ShastaUpdate as main_ctrl

# pylint: disable=consider-using-f-string

install_logger = get_install_logger()

STAGES = OrderedDict({
    "process_product_media": {
        "func" : main_ctrl.get_prods,
        "description" : "Inventory and extract products in the media directory for use in subsequent stages."
        },
    "validate_products":  {
        "func" : main_ctrl.validate_products,
        "description" : "Perform product sanity checks."
        },
    "install_products": {
        "func" : main_ctrl.install,
        "description" : "Install products identified in the process_product_media stage."
        },
    "verify_product_import": {
        "func" : main_ctrl.verify_product_import,
        "description" : "Verify all product import PODS and Jobs have completed."
        },
    "verify_product_install": {
        "func" : main_ctrl.verify_product_install,
        "description" : "Verify product installation by running product validations"
        },
    "update_working_branches": {
        "func" : main_ctrl.update_working_branches,
        "description" : """Update config managment branches identified by --working-branch with the product
                                release branch content for each product being installed that contains a
                                config management repo.  See help for --working-branch for details on
                                setting the working branch."""
        },
    "update_ncn_config": {
        "func" : main_ctrl.update_ncn_config,
        "description" : """Update the NCN personalization configuration.  Defaults to 'ncn-personalization',
                                use --ncn-personalization to over-ride."""
        },
    "worker_health_check": {
        "func":  main_ctrl.worker_health_check,
        "description": "Check the health of the workers prior to beginning NCN Personalization."
    },
    "ncn_personalization": {
        "func" : main_ctrl.ncn_personalization,
        "description" : "Perform NCN personalization."
        },
    "unload_dvs_and_lnet": {
        "func" : main_ctrl.unload_dvs_and_lnet,
        "description" : "Perform a rolling unload, upgrade and reload of DVS and LNET on worker nodes."
        },
    "check_services": {
        "func" : main_ctrl.check_services,
        "description" : "Check CPS, DVS, LNET. and NMD services."
        },
    "create_cos_cfs_config": {
        "func" : main_ctrl.create_cos_cfs_config,
        "description" : "Write the CFS config used for building the COS image."
        },
    "create_bootprep_config": {
        "func" : main_ctrl.create_bootprep_config,
        "description" : "Generate the `sat bootprep` input config."
        },
    "sat_bootprep": {
        "func" : main_ctrl.sat_bootprep,
        "description" : "Run `sat bootprep`."
        },
})

NOABORT_STAGES = [
]

def format_tabbed_list(alist):
    """Format a list into text that's easier to read.  This is useful when
    a list needs to be displayed to a user."""
    retstr = ""
    for elt in alist:
        retstr += "  {}\n".format(elt)

    return retstr

def get_stages(long=False, all=False):
    ret = []

    longest = max(map(len, STAGES.keys()))

    for stage in STAGES.keys():
        display = STAGES[stage].get("display", True)
        if not display and not all:
            continue
        stagestr = stage
        if long:
            description = STAGES[stage].get("description", False)
            if description:
                stagestr = "{stage:{width}} : {description}".format(stage=stage, width=longest, description=description)

        ret.append(stagestr)

    if long:
        return format_tabbed_list(ret)
    else:
        return ret

def validate_stages(args_dict):
    """Validate that all of the various stage related args passed in are valid"""
    # Do some error-handling with the stage-related args
    stages_list = get_stages(all=True)
    stages_formatted = get_stages(long=True)

    # load all of the stage variables
    begin_stage = args_dict.get('begin_stage')
    end_stage = args_dict.get('end_stage')
    run_stages = args_dict.get('run_stages')
    skip_stages = args_dict.get('skip_stages')

    # wait to exit until we process all the stages
    error=False

    # if they've specified begin or end along with run_stages, we no longer have any idea
    # what they're talking about.  Don't allow it.
    if begin_stage is not None or end_stage is not None:
        if run_stages:
            install_logger.error("argument -r/--run-stages: not allowed with -b/--begin-stage or -e/--end-stage")
            error=True

    # run and skip at the same time is equally nonsensical
    if run_stages and skip_stages:
        install_logger.error("argument -r/--run-stages: not allowed with -s/--skip-stages")
        error=True

    if begin_stage is None:
        begin_stage = stages_list[0]

    if end_stage is None:
        end_stage = stages_list[-1]

    if begin_stage not in stages_list:
        install_logger.error("invalid stage ({}) found in --begin-stage".format(begin_stage))
        error=True

    if end_stage not in stages_list:
        install_logger.error("invalid stage ({}) found in --end-stage.".format(end_stage))
        error=True

    if run_stages:
        for stage in run_stages:
            if stage not in stages_list:
                install_logger.error("invalid stage ({}) found in --run-stages".format(stage))
                error=True

    # don't need to log the help information, just print and exit
    if error:
        print("\nAll stages must be one of the following:\n{}".format(stages_formatted))
        sys.exit(1)

    # Let args_dict['run_stages'] override begin_stage and end_stage; that is,
    # if all three were passed in, run_stages wins.  Loop against stages_list
    # to preserve the execution order.
    if run_stages:
        got_first_stage = False
        for stage in stages_list:
            if stage in run_stages and not got_first_stage:
                begin_stage = stage
                end_stage = stage
                got_first_stage = True
            elif stage in run_stages:
                end_stage = stage

    # Determine if any stages can be skipped.
    if skip_stages is None:
        skip_stages = list()

    if not isinstance(skip_stages, list):
        # This may happen if it skip_stages was passed it via the input file.
        print("'-s/--skip-stages' argument should be a list")
        sys.exit(1)

    for sstage in skip_stages:
        if sstage not in stages_list:
            install_logger.error("invalid stage ({}) found in --skip-stages".format(sstage))
            error=True

    begin_idx = stages_list.index(begin_stage)
    end_idx = stages_list.index(end_stage)
    install_logger.debug("begin_idx={}, end_idx={}, len(stages_list)={}".format(begin_idx, end_idx, len(stages_list)))
    stages = [stages_list[i] for i in range(begin_idx, end_idx + 1) if stages_list[i] not in skip_stages]
    install_logger.debug("stages={}".format(stages))
    install_logger.debug("(begin,end)_idx = ({},{})".format(begin_idx, end_idx))
    args_dict["stages"] = stages
    if "func" in args_dict and args_dict["func"] == process_install:
        install_logger.info("STAGE SUMMARY: begin_stage={}, end_stage={}".format(begin_stage, end_stage))

    # Check some of the commandline arguments up front to prevent wasted time.

    # Check the BOS sessiontemplate and CFS config arguments.  If the CFS
    # config is not explicitly specified, it can be obtained from the BOS
    # sessiontemplate.
    if "source_bos_sessiontemplate" in args_dict and args_dict["source_bos_sessiontemplate"] is None \
        and "create_bootprep_config" in stages:
        msg = formatted("""
            When creating a bos session template,  a source bos sessiontemplate
            (-t or --source-bos-sessiontemplate) is required""")
        print(msg)
        sys.exit(1)
    elif "source_bos_sessiontemplate" in args_dict and args_dict["source_bos_sessiontemplate"]:
        bos_template = json.loads(main_ctrl.connection.sudo("cray bos sessiontemplate describe {} --format json".format(
            args_dict["source_bos_sessiontemplate"])).stdout)
        bos_cfs_config_name = bos_template["cfs"]["configuration"]

        if "cfs_config" not in args_dict or args_dict["cfs_config"] is None:
            args_dict["cfs_config"] = bos_cfs_config_name
        elif "cfs_config" in args_dict and args_dict["cfs_config"] is not None:
            if args_dict["cfs_config"] != bos_cfs_config_name:
                msg = formatted("""
                    The cfs-config argument passed in ({}) will be used in
                    image building and creating the bos  sessiontemplate.
                    This differs from the one found in the bos
                    sessiontemplate ({}).  The one found in {} was {}""".format(
                    args_dict["cfs_config"],
                    args_dict["source_bos_sessiontemplate"],
                    args_dict["source_bos_sessiontemplate"],
                    bos_cfs_config_name))
                install_logger.warning(msg)

    # Ensure that working_branch is specified if it's needed.
    if ("working_branch" in args_dict and args_dict["working_branch"] is None) \
        and (("update_working_branches" in stages) \
        or ("update_ncn_config" in stages)):
            msg = formatted("""
                Please supply --working-branch with stages update_working_branches or update_ncn_config.""")
            print(msg)
            sys.exit(1)

    # Ensure that if a `sat bootprep` config was specified (and the stage
    # is being run) it exists.
    bp_config = args_dict.get("bootprep_config", None)
    if bp_config and "sat_bootprep" in stages:
        if not os.path.exists(bp_config):
            print("--bootprep-config/-bpc {} was specified but could not be found".format(bp_config))
            sys.exit(1)

    return


def process_install(args_dict):
    """Run the install"""
    stages_list = get_stages(all=True)
    stages = args_dict["stages"]

    installer_start = datetime.datetime.now()
    for stage in stages_list:
        if stage in stages:
            install_logger.info("Beginning stage: {}".format(stage))
            # a logging message using exc_info must be the very first thing called after the except
            # block starts, so I can't make all these decisions there
            if stage in NOABORT_STAGES:
                log_level=LOG_LEVELS["WARNING"]
            else:
                log_level=LOG_LEVELS["ERROR"]

            try:
                stage_start = datetime.datetime.now()
                STAGES[stage]["func"](args_dict)
                install_logger.info("  stage completed in {}".format(elapsed_time(stage_start)))

            except RunException as err:
                # if this was an unhandled, failed command, print details
                install_logger.info("  aborting stage after {}".format(elapsed_time(stage_start)))
                install_logger.debug("Exception while executing {}".format(stage), exc_info=True)
                print("")
                install_logger.critical("The following command failed while executing {}:".format(stage))
                print("")
                install_logger.error("   CMD: {}".format(err.cmd))
                for item in ["stdout", "stderr", "returncode"]:
                    if hasattr(err, item):
                        rawmsg = str(eval("err."+item))
                        msglines = rawmsg.splitlines()
                        for line in msglines:
                            if line:
                                install_logger.error("{}: {}".format(item, line))
                print("")
                install_logger.info("Aborting install after {}".format(elapsed_time(installer_start)))
                print("")
                sys.exit(1)

            except Exception as err:
                install_logger.info("  aborting stage after {}".format(elapsed_time(stage_start)))
                install_logger.debug("Exception while executing {}".format(stage), exc_info=True)
                print("")
                install_logger.critical("A '{}' error".format(err))
                install_logger.critical("occured while executing {}".format(stage))

                print("")
                install_logger.info("Aborting install after {}".format(elapsed_time(installer_start)))
                print("")
                sys.exit(1)

    install_logger.info("Install completed in {}".format(elapsed_time(installer_start)))


def process_list(args): #pylint: disable=unused-argument
    """Process the arguments to the list subparser"""
    stages = get_stages(long=True)
    print(stages)

def process_products(args):
    products = get_product_prefixes(desc=True)
    media = args['media_dir']

    def arc_wanted(f, prefix):
        if f.is_file() and f.name.startswith(prefix):
            if tarfile.is_tarfile(f.path):
                return True

        return False


    header = ['Archive Prefix', 'Product Description']
    alignments = dict()
    alignments['Archive Prefix'] = "r"
    alignments['Product Description'] = "l"

    rows = []
    archives = []
    for prefix,description in products.items():
        rows.append([prefix,description])
        found = [ f.name for f in os.scandir(media) if arc_wanted(f,prefix) ]
        archives.extend(found)

    scriptname = os.path.basename(__file__)
    print("The following products are supported by {}:".format(scriptname))
    print_table(rows, header, 'Archive Prefix', alignments)
    print ("Matching products in", media)
    for archive in archives:
        print ("  ",archive)


def process_debug_level(cmdline_args):
    install_logger_file_init(cmdline_args)
    if "level" in cmdline_args.keys() and cmdline_args["level"] != None:
        if cmdline_args["level"] in LOG_LEVELS.keys():
            level = LOG_LEVELS[cmdline_args["level"]]
            install_logger_stream_init(level, cmdline_args.get("verbose", False))
        else:
            # when this runs we don't have a logger yet, just print and exit
            print("ERROR: Unrecognized log level: {}".format(cmdline_args["level"]))
            sys.exit(1)
    else:
        install_logger_stream_init(verbose=cmdline_args.get("verbose", False))

    log_dir_base = cmdline_args["log_dir"]
    log_dir = os.path.join(log_dir_base, SESSION_TIMESTAMP)
    install_logger.info("All logs will be stored in {}".format(log_dir))
    return


def process_dryrun(cmdline_args):
    """
    Sets the static CmdInterface interface to "dryrun" mode
    """
    dryrun = cmdline_args.get("dryrun", False)
    connection = CmdMgr.get_cmd_interface()
    connection.dryrun = dryrun

    if dryrun:
        addLoggingLevel('DRYRUN', logging.INFO + 1)
        install_logger.dryrun("Dryrun enabled")

def check_environment_variables():
    """
    Go over a list of variables that we don't want set and remove them
    """

    CLEAN_ENV = [
        "CRAY_FORMAT",
    ]

    for var in CLEAN_ENV:
        if var in os.environ:
            del os.environ[var]

def main():
    """Main entry point."""
    check_environment_variables()

    parser = argparse.ArgumentParser(description=
        """
       The Compute Node Environment (CNE) installer.
        """
    )

    parser.add_argument("-i", "--input-file", action="store", help="""Input
        file used to control the install.   Command line arguments will
        override what is in the file.
        Input file should be YAML.""")

    parser.add_argument("-w", "--write-input-file", action="store_true",
        help="""Write out a new config file to the input file specified with defaults+
        any command line options specified and quit.""")

    parser.add_argument("-s", "--state-dir", action="store",
        help="A directory used to store the current state of stages.  Defaults to $PWD/state")

    parser.add_argument("-m", "--media-dir", action="store",
        help="Location of installation media you would like to install.  Defaults to $PWD/media")

    parser.add_argument("--log-dir", action="store", default=LOG_DEFAULT_DIR,
        help="Location used to store log files.  Defaults to $PWD/log")

    parser.add_argument("--dryrun", action=InvertableArgument, default=False,
        help="Run without making any changes to the system to see what would happen")

    parser.add_argument("-l", "--level", action="store", default='INFO',
        help="Set the debug level to the console", choices=LOG_LEVELS.keys())

    parser.add_argument("-v", "--verbose", action="store_true",
        help="Generates more verbose messages")

    # TODO: The stage-dir usage could use more verbiage. We might want to add
    # this to the install docs.  Describing it in detail in the help section
    # might be inappropriate.  Essentially, we need it because not all the stages
    # are fully independent; for example, we have an unpack stage, and an
    # install stage.  The install stage needs to install what was unpacked.

    subparsers = parser.add_subparsers(title="subcommands")
    stage_list = get_stages(long=True)

    install_sp = subparsers.add_parser("install", epilog="Valid stages:\n{}".format(stage_list),
        formatter_class=argparse.RawTextHelpFormatter)

    install_sp.add_argument("-b", "--begin-stage", action="store",
        help="The first stage to execute")

    install_sp.add_argument("-c", "--cfs-config", action="store",
        help="The CFS configuration to be used during image building.")

    install_sp.add_argument("-e", "--end-stage", action="store",
        help="The last stage to execute")

    install_sp.add_argument("-r", "--run-stages", nargs="+", action="store",
        help="Run only the specified stages")

    install_sp.add_argument("-s", "--skip-stages", nargs="+", action="store",
        help="Skip the execution of the specified stages")

    install_sp.add_argument("-B", "--working-branch", action="store",
        help="""String representing the working branch in each product config
management repo that the product release branch will be merged to.

The following substitutions may be used:

    {{product_key}}    Product name + version formatted per distribution media
                       ex: slingshot-host-software-1.7.1-32-cos-2.2
    {{product_type}}   Type of product.
                       ex: 'cos', 'slingshot-host-software', 'sles'
    {{version_full}}   Full product version as it appears in the product catalog.
                       ex: 1.7.1-32-1.0.19
    {{version_x_y_z}}  x.y.z version of the product
    {{version_x_y}}    x.y version of the product

For example, if the following value was used for COS 2.2.93 and SHS 1.7.1:

    --working-branch '{{product_type}}-{{version_x_y_z}}-integration'

Then the following would be the branches used:

    For COS: 'cos-2.2.93-integration'
    For SHS: 'slingshot-host-software-1.7.1-integration'

As a result, the update_working_branches stage would perform the following merges:

    cray/cos/2.2.93 --> cos-2.2.93-integration
    cray/slingshot-host-software/1.7.1 --> slingshot-host-software-1.7.1-integration
        """)

    bpc_help = formatted("""
    Use an alternate `sat bootprep` config file than is generated during the
    `create_bootprep_config` stage.""")

    install_sp.add_argument("-bpc", "--bootprep-config", action="store",
        help=bpc_help)
    install_sp.add_argument("-t", "--source-bos-sessiontemplate", action="store",
        help="BOS template to start from when booting COS")

    install_sp.add_argument("-crn", "--cos-recipe-name", action="store",
        help="The name of the recipe to build the COS compute image")

    install_sp.add_argument("-ncnp", "--ncn-personalization", action="store",
        default="ncn-personalization",
        help="The name of the ncn personalization config to update.  Defaults to 'ncn-personalization'")

    install_sp.add_argument("-D", "--dvs-update-method", action="store",
        choices=["auto", "legacy", "ncn-upgrade"],
        default="auto",
        help="""Defaults to 'auto'.  Method used to update COS on the NCN nodes.  This is primarily to
update from one version of DVS to another.  The 'legacy' mode is the proceedure used in
COS <= 2.2.  The 'ncn-upgrade' mode utilizes the 'ncn-upgrade.yml' playbook introduced
in COS 2.3.  The 'auto' mode will utilize the ncn-upgrade mode if all the needed conditions
are present (the ncn-upgrade.yml playbook must be in the COS working branch AND the
ncn-personalization config must contain the slingshot-host-software layer) and the
'legacy' mode if not.""")

    install_sp.add_argument("-wn", "--worker-nodes", action="store",
        help="""Override worker list used in DVS reload stage to assist with repairing broken nodes.
Can be a regular expression or text string.
For example, --worker-nodes ncn-w003 would cause the ncn_personalization stage to only
reload ncn-w003.
""")

    install_sp.set_defaults(func=process_install, skip_stages=list(), run_stages=list())

    list_sp = subparsers.add_parser("list-stages", aliases=["ls"])
    list_sp.set_defaults(func=process_list)

    products_sp = subparsers.add_parser("list-products")
    products_sp.set_defaults(func=process_products)

    # create a config object to store all of the configured options in the parser
    config = Config()
    config.load_parser_defaults(parser)

    # parse the arguments once to get input file
    tmp_args = parser.parse_args()

    # load any defaults from the input file
    config.set_defaults(parser,vars(tmp_args))

    # parse the command line for real
    args = parser.parse_args()

    # Convert the args to a dict, and use that rather than the argparse
    # object.  This is so that we have a dictionary of all options, so that
    # we can more easily determine which values can be passed via an input
    # deck.
    args_dict = vars(args)

    # Set up the media and state directories.  This needs to be done prior
    # to any real processing, since most of the functionality is dependent on
    # them.
    if args_dict["media_dir"] is None:
        media_default = os.path.join(os.getcwd(), "media")
        args_dict["media_dir"] = media_default
        if not os.path.exists(media_default):
            os.mkdir(media_default)

    if args_dict["state_dir"] is None:
        state_default = os.path.join(os.getcwd(), "state")
        args_dict["state_dir"] = state_default
        if not os.path.exists(state_default):
            os.mkdir(state_default)

    process_debug_level(args_dict)
    process_dryrun(args_dict)
    install_logger.debug(args_dict)

    if len(sys.argv) < 2:
        install_logger.error("{} requires at least 1 argument".format(sys.argv[0]))
        parser.print_help(sys.stderr)
        sys.exit(1)

    # some sanity testing
    if not os.path.exists(args_dict["media_dir"]):
        install_logger.error("Media directory {} does not exist.".format(args_dict["media_dir"]))
        sys.exit(1)

    if not os.path.exists(args_dict["state_dir"]):
        install_logger.error("State directory {} does not exist.".format(args_dict["state_dir"]))
        sys.exit(1)

    validate_stages(args_dict)

    if args_dict["write_input_file"]:
        config.write(args_dict)

    try:
        args.func(args_dict)
    except AttributeError:
        install_logger.error("A subcommand was not specified.")
        parser.print_help(sys.stderr)
        sys.exit(1)
if __name__ == "__main__":
    main()
